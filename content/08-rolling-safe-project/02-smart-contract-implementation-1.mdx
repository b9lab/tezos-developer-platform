---
title: Smart Contract Implementation I
description: 
slug: /cso-smart-contract-implementation-part-1
---

<HighlightBox type="info">

Before working on this section, please read the [Continuous Organizations Whitepaper](https://github.com/C-ORG/whitepaper) by Thibauld Favre. In this section, we will present an implementation of the ideas in the whitepaper, our TZMINT project.

B9lab's sample project is an implementation of a contnious programmable equity offering also known as a Rolling SAFE. For more details on this novel funding mechanism, take a look at the [previous section](...).

To see the implementation in action, please visit the [TZMINT platform](https://tzmint.b9lab.com/), which is hosted by [B9lab](https://b9lab.com/). It is better to first try out the platform before taking a closer look at the implementation description in this course. 

</HighlightBox>

We implemented our smart contract in [SmartPy](https://smartpy.io/). To keep things simple, the tokens are represented as a simple map.

<HighlightBox type="tip">

Need a recap on SmartPy? No worries! We recommend a look at the chapter [Writing Smart Contracts](./smart-contracts).

</HighlightBox>

The contract has **three entrypoints**:

* `buy`,
* `sell`, and
* `close`.

In this section, we will begin with an explanation of the `buy` function. Afterwards, in the [next section](...), we will talk about the `sell` and `close` functions (closing function). For the sake of simplicity, we will not implement the entrypoints for `burn` and `pay`.

<HighlightBox type="tip">

You can find the smart contract in the [project repository](...).

If you want to extend this smart contract to, for example, fullfil the FA2 token standard, you will need to implement additional entrypoints. You can find more information regarding the token standard in the [FA2](...) section.

</HighlightBox>

# The `buy` function

`buy` will calculate the number of tokens for the sent amount of tez and it will mint these tokens. In addition, it should sent back the excess amount.

There are **two phases** in the offering regarding the buy price:

1. The **initial phase**: Before the minimum funding goal (MFG) is reached, the buy price is constant; 
2. The **slopy phase**: Once the MFG is reached, the buy price will increase for each issued token.

<HighlightBox type="tip">

If this phases do not sound familiar, take another look at the [past section](...), especially _Stages in a Rolling SAFE_.

</HighlightBox>

The buy price is determined during the **initial phase** by the following lines in the contract code:

```python
    # initial phase, the price is fix
    def buy_initial(self, amount):
        # calculate amount of tokens from sp.amount and the price
        token_amount = sp.local(
            "token_amount", 
            sp.ediv(
                amount, 
                self.data.price
                ).open_some("Fatal Error: Price is zero")
            )
```

In this phase, the calculation is `token_amount = amount/self.data.price`, where `amount` represents the number of tokens (in tez) sent with the transaction and `self.data.price` is the current price of the token.

After the calculation, `buy_initial` will check if any tokens can be issued. Then it will add the calculated number of tokens to the ledger linking them to the transaction sender. In case no record of the user exists, it will create an entry. The comments in the code should be sufficient as an explanation:

```python
        # fail if no tokens can be issued with this amount of tez
        sp.if sp.fst(token_amount.value) == sp.as_nat(0):
            sp.failwith("No token can be issued, please send more tez")
            
        # check if the address owns tokens
        sp.if self.data.ledger.contains(sp.sender):
            # add amount of the tokens into the ledger
            self.data.ledger[sp.sender] += sp.fst(token_amount.value)
        sp.else:
            # put amount of the tokens into the ledger
            self.data.ledger[sp.sender] = sp.fst(token_amount.value)
            
        # increase total amount of the tokens
        self.data.total_tokens += sp.fst(token_amount.value)

        # keep received funds in this contract as buyback reserve
        # but send back the excess
        sp.if sp.utils.mutez_to_nat(sp.snd(token_amount.value)) > 0:
            sp.send(sp.sender, sp.snd(token_amount.value))

        # track how much is invested
        self.data.total_investment = self.data.total_investment + amount - sp.snd(token_amount.value)
```

Before calculating the recent value of the total investments, the excess is calculated and sent back to the user.

Now, let us have a look at the **slopy phase** for the `buy` function:

```python
    # after initial phase, the price will increase
    def buy_slope(self):
        # calculate amount of tokens from sp.amount
        # see https://github.com/C-ORG/whitepaper#buy-calculus

        token_amount = sp.local(
            "token_amount", 
            self.square_root(
                2 * sp.utils.mutez_to_nat(sp.amount) /self.data.b + 
                self.data.total_tokens * self.data.total_tokens
                ) - self.data.total_tokens
            )

        tez_amount = sp.local(
            "tez_amount",
            sp.as_nat(token_amount.value) * self.data.total_tokens * self.data.b   /2 + 
            (sp.as_nat(token_amount.value) + self.data.total_tokens) * sp.as_nat(token_amount.value) * self.data.b/2
            )

        send_back = sp.local(
            "send_back",
            sp.amount - sp.utils.nat_to_mutez(tez_amount.value)
            )
```

This time the calculation for the `token_amount` is more complex because of the linear price increase. We have to calculate the [area of the triangle](https://github.com/C-ORG/whitepaper#buy-calculus) under the price function.

![Calculating the buy price post-MFG](/images/buy-calculus.png)

You can find the same calculation in the [Javascript code](...) too.

Next, the contract does a **reserve-calculation** to determine the amount of the excess, which we send back in the next lines:

```python
        # send tez that is too much
        sp.if sp.utils.mutez_to_nat(send_back.value) > 0:
            sp.send(sp.sender, send_back.value)

        # track how much is invested
        self.data.total_investment += sp.utils.nat_to_mutez(tez_amount.value)

        # fail if no tokens can be issued with this amount of tez
        sp.if sp.as_nat(token_amount.value) == sp.as_nat(0):
            sp.failwith("No token can be issued, please send more tez")
            
        # calculate buyback reserve from sp.amount I*sp.amount/100
        buyback_reserve = sp.local(
            "buyback_reserve", 
            sp.utils.nat_to_mutez(self.data.I * tez_amount.value / sp.as_nat(100))
            )
        
        company_pay = sp.local(
            "company_pay",
            sp.amount - buyback_reserve.value
            )

        # send (100-I) * sp.amount/100 of the received tez to the organization
        sp.send(self.data.organization, company_pay.value)
        # this will keep I * sp.amount/100 in this contract as buyback reserve
            
        # check if the address owns tokens
        sp.if self.data.ledger.contains(sp.sender):
            self.data.ledger[sp.sender] += sp.as_nat(token_amount.value)
        sp.else:
            self.data.ledger[sp.sender] = sp.as_nat(token_amount.value)
                 
        # increase total amount of the tokens
        self.data.total_tokens += sp.as_nat(token_amount.value)
```

Each time someone buys a token, a part of the tez amount in the transaction will be kept for the buyback reserve.

<HighlightBox type="info">

At the end of a `buy_slope` call, the contract updates the sell slope. This is something we address in the [next section](...).

</HighlightBox>

Now we can look at the `buy` entrypoint and understand the conditions for calling the initial or slope buy function:

```python
    # buy some tokens with sender's tez
    @sp.entry_point
    def buy(self):
    #check the phase, dont sell or buy if closed
        sp.if self.data.phase != 2:
            # if token in intialization phase, the price is fixed and all funds are escrowed
            sp.if self.data.total_investment < self.data.MFG:
                # check the excess above MFG and send back
                sp.if sp.utils.mutez_to_nat(self.data.MFG - sp.amount - self.data.total_investment) < 0:
                    sp.send(sp.sender, sp.amount - self.data.MFG + self.data.total_investment)
                    self.buy_initial(self.data.MFG - self.data.total_investment)
                sp.else:
                    self.buy_initial(sp.amount)
            # if initialization phase is past
            sp.else:
                self.data.phase = 1
                self.buy_slope()
 ```

You can see, that we do not allow any action to take place after the closing phase.

Moreover, we do an additional check for the **excess**, which gets send back. The excess in the `buy` function is a different one than the excess in the `buy_initial` and `buy_slope` functions.

Imagine a scenario We basically do not want to mix the initial and the slopy phase so the contract will allow to buy tokens till the MFG and the user will need another call to continue to buy in the slopy phase.

