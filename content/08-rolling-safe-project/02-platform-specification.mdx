---
title: Web Application Specification - Planning & Workflows
description: 
slug: /cso-platform-specification
---

import HighlightBox from "../../src/components/HighlightBox"

Due to the size of this project, we need to do some planning before starting to code. We will showcase our actual approach for the implementation of this whole project, and share our considerations and learnings.

On the top level, we have divided the project into two separate parts:

* The user-facing web application, the **[TZMINT web application](https://tzmint.b9lab.com/)**, and
* The smart contract and the **wrapper functions** to interact with it.

This division of concerns allows developing both parts in parallel while decreasing the complexity on each side. To ensure both parts fit together in the end, we drew a hard line between these two parts. Both are only connected through one interface: the **DataHandler**.

![Division of concerns - System split](./images/system-split-l.png)

The [`DataHander`](https://github.com/b9lab/tezos-cso-project/blob/master/src/services/DataHandler.ts) is written in JavaScript and exposes all functions for the web application to interact with the blockchain on a high level (both read and write). For the developer working on the web application implementation, this handler allows all interaction and does not require developers to know the actual smart contract implementation.

On the other side, the `DataHandler` directly calls the wrapper functions implemented by the smart contract team, which does not need to know about the processing of this data in the web application beyond the wrapper functions. The call to the wrapper functions is also implemented in the `DataHandler` - so we really drew the line _through_ it.

With this setup, the team working on the web application does not need to be fully knowledgeable about all the blockchain-related details, while the smart contract team just needs normal JavaScript/TypeScript to implement the wrappers without knowledge regarding both frontend and backend frameworks (React, Next, Express). Not everyone needs to be a full-stack developer.

After a quick general project introduction (i.e. an explanation of the Rolling SAFE) and the development of the base user stories, both teams worked together on the specification of the function signatures and the return data for the [`DataHandler`](https://github.com/b9lab/tezos-cso-project/blob/master/src/services/DataHandler.ts) on a basic level:

```javascript
@return Promise.resolve(number totalInvestors) or Promise.reject(error)
chainWrapper.totalInvestors()

@return Promise.resolve(number totalInvestments) or Promise.reject(error)
chainWrapper.totalInvestments()

@return Promise.resolve(number companyValuation) or Promise.reject(error)
chainWrapper.companyValuation()
```

You can take a look at the [full (original) specification document](https://docs.google.com/document/d/1_7sPfupI5JVjYDt1_PoFcq1q-QQoLq1SNBt3kfY2M4U) to get a feel for our first approach - Please note that this document was our very first specification document. After we had created this document, we began to implement the DataHandler with stubs, which then became our new specification file.

An example stub for the `getInvestmentNumbers()` function in the [very first version](https://github.com/b9lab/tezos-cso-project/blob/72ce67a34d8aa99e38895595033900e00d4f7b70/src/services/DataHandler.ts#L46) is:

```typescript
// General Investment Info

getInvestmentNumbers(): Promise<InvestmentNumbersDto> {
    return new Promise((resolve, reject) => {
        const data: InvestmentNumbersDto = {
            totalInvestment: '$2,000',
            investorsCount: 238,
            tokensCount: 37,
            unlockingDate: new Date("2021-07-30 12:05:33.574+00")
        };

        resolve(data);
    });
}

```

On the web application side, this common `DataHandler` with stubs allows to immediately start with the implementation of the scenarios with their views and flows. For the smart contract development, this is a perfect blueprint to be used as expected values in unit tests allowing to start with **test-driven development** right away.

Later, the stubs are replaced with the `chainWrapper` methods according the signatures:

```typescript

class DataHandler {

    /**
     * Gets the general investment numbers
     */
    async getInvestmentNumbers(): Promise<InvestmentNumbersDto> {
        const start = new Date(process.env.DEPLOYMENT_DATE || "2021-07-21T14:02:43Z");
        const end = new Date();
        const steps = 30;

        const storage = await chain.storage();
        const [
            companyName, 
            buyPrice, 
            sellPrice, 
            minimumFundingGoal, 
            totalInvestments, 
            investorsCount, 
            totalTokens, 
            reserveAmount, 
            sellSlope,
            buySlope, 
            unlockingDate,
            burnedTokensCount,
            phase,
            priceHistory
        ] = await Promise.all([
            chain.companyName(storage), 
            chain.buyPrice(storage, 1),
            chain.sellPrice(1),
            chain.mfg(storage),
            chain.totalInvestments(storage),
            chain.totalInvestors(storage),
            chain.totalTokens(storage),
            chain.reserveAmount(),
            chain.sellSlope(storage),
            chain.buySlope(storage),
            chain.unlockingDate(storage),
            chain.burnedTokens(storage),
            chain.phase(storage),
            chain.priceHistory(start, end, steps)
        ]);

        return {
            companyName: companyName,
            tokenBuyPrice: +buyPrice,
            tokenSellPrice: +sellPrice,
            minimumFundingGoal: +minimumFundingGoal,
            unlockingDate: unlockingDate,
            totalInvestment: +totalInvestments,
            investorsCount: +investorsCount,
            tokensCount: +totalTokens,
            burnedTokensCount: +burnedTokensCount,
            reserveAmount: +reserveAmount,
            buySlope: +buySlope,
            sellSlope: +sellSlope,
            isMFGReached: !!+phase,
            prices: priceHistory
        };
    }
```

## Workflows

Not everything can be perfectly defined in the beginning. For example, the [`getUserTransactionData`](https://github.com/b9lab/tezos-cso-project/blob/72ce67a34d8aa99e38895595033900e00d4f7b70/src/services/DataHandler.ts#L129) function was originally planned to return one list with all user transactions. After multiple evolutions, it [ended up](https://github.com/b9lab/tezos-cso-project/blob/main/src/services/DataHandler.ts#L356) returning two separate lists with an updated format, one for funding and one for withdrawal transactions.

<HighlightBox type="tip">

Even with the best planning, it is natural that you will need to update this file at some point, as some details evolve during the course of a project. Plan in both **time** and **processes** to keep this common interface in sync on both sides.

</HighlightBox>

## Two parts, two repositories

To further untangle these two main parts, we also use two separate repositories:

* The [web application repository](https://github.com/b9lab/tezos-cso-project), and
* The [smart contract and wrapper repository](https://github.com/b9lab/tezos-app-project).

The smart contract repository is integrated into the web application repository as a [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules). This split into two repositories allows for separate ci/cd workflows and less friction on pull request reviews, all helping to speed up the development when working in a team.

When a change on the smart contract functions is requested from the web application team, we first adjust the unit tests in the smart contract repository, then sync these to the `DataHandler` stubs, and only then begin implementing the changes on both sides.

During the initial development, it was also very easy to update the stubbed functions with this split up once the smart contract and wrapper functions were ready, as the smart contract team could easily replace the stubbed data fields with the wrapper calls and push this update to the web application team to connect their functions.
