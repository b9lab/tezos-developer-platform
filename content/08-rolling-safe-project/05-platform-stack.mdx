---
title: Platform Stack
description: 
slug: /cso-platform-stack
---

We have two different kind of interactions with the blockchain: __transactions__ and __queries__

As you learned in the previous modules, we need to sign a transaction and send it to a node. Queries have a different nature, we are not forced to communicate with a Tezos node directly and we do not need any signatures. 

# Transactions

We call the entrypoints like you learned in the [Taquito Section](./taquito). You will see in the [contractWrapper](...):

```javascript
    return {

        "buy": (tezAmount) => {
            return confirmDefault((contract) => {
                return contract.methods.buy([["unit"]]).send({"amount": tezAmount});
            });
        },
        "sell": (tokenAmount) => {
            return confirmDefault((contract) => {
                return contract.methods.sell(tokenAmount).send();
            });
        },
        ...
    };
```

`contract` is basicly `tezos.wallet.at(contractAddress)`, so the transactions are signed by a wallet:

```javascript
        wallet = new options.SDK(walletOptions),
        forcePermissionRequest = () => {
            return wallet
                .client
                .requestPermissions({
                    "network": {
                        "type": options.network,
                        "rpcUrl": options.url
                    }
                })
                .then(() => {
                    return wallet;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        };
```

We use `BeaconWallet`; Please check the [Beacon Section](./beacon), if you are not familiar with it.

# Queries

TzKT API is used to fetch information from the Tezos blockhain. You can find the methods the platform implements in the [chainWrapper](...) code.

<HighlightBox type="tip">

You can find the [TzKT Section](./tzkt) in the Clients Module

</HighlightBox>

We will need different endpoints of the API to fetch all the information you can see at the [TZMINT](https://tzmint.b9lab.com/) platform. It makes sense to have a function for each of the endpoints we want to use:

```javascript
/* eslint-disable max-lines */
    const requestStorage = (level) => {
            const levelRequest = typeof level === "undefined"
                ? ""
                : `?level=${level}`;


            return axios.get(`${apiEndpoint}v1/contracts/${contractAddress}/storage${levelRequest}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        requestStorageHistory = (limit) => {
            const limitRequest = typeof limit === "undefined"
                ? ""
                : `limit=${limit}`;

            return axios.get(`${apiEndpoint}v1/contracts/${contractAddress}/storage/history?${limitRequest}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        ...
```

`chainWrapper` uses [axios](https://github.com/axios/axios) as HTTP client for the queries. The endpoint to get the storage of a contract is `/contracts/${contractAddress}/storage`. We include a `level` and `levelRequest` because we will also fetch the storage for a given block level. In additionn we want to be able to fetch the changes in the storage, so there is  a `requestStorageHistory` method. 

Let us check other methods for the endpoints:

```javascript
        transactions = (sender, entrypoint) => {
            const url = `${apiEndpoint}v1/operations/transactions?target=${contractAddress}`,
                senderFilter = typeof sender === "undefined"
                    ? ""
                    : `&sender=${sender}`,

                entryFilter = typeof entrypoint === "undefined"
                    ? ""
                    : `&entrypoint=${entrypoint}`;

            return axios.get(url + senderFilter + entryFilter)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });

        },
        balance = (address) => {
            return axios.get(`${apiEndpoint}v1/accounts/${address}/balance_history`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        payedAmount = (hash) => {
            return axios.get(`${apiEndpoint}v1/operations/transactions/${hash}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        }
```

so we need some transaction details and account balances. Least we have a helper function, which is used to avoid unnecessary queries:

```javascript
        cashedData = (cashedStorage, storageFunction, functionToCash) => {
            if (cashedStorage) {
                return functionToCash(cashedStorage);
            }
            return storageFunction().then(functionToCash);
        };
```

First you will see a lot of information we fetch from the storage and we do not expect always such a value to be changed:

```javascript
    return {
        "storage": requestStorage,
        "totalTokens": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.total_tokens, 10);
            });
        },
        "totalInvestments": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.total_investment, 10);
            });
        },
        "mfg": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.MFG, 10);
            });
        },
        "sellSlope": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.s, 10);
            });
        },

        ...

        "companyValuation": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.company_v, 10);
            });
        },
        "phase": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.phase, 10);
            });

        },
```


We cannot easly fetch the sell and the buy price. So in the `buyPrice` we do a calculation for a given number of tokens and return the estimated price. This is also true for the `sellPrice`:

```javascript
        "buyPrice": (storageData, tokens) => {
            return cashedData(storageData, requestStorage, (data) => {
                const firstPart = data.b * data.total_tokens * tokens / 2,
                    secondPart = data.b * tokens * (parseInt(data.total_tokens, 10) + tokens) / 2,
                    tempPrice = Math.ceil((firstPart + secondPart)*10)/10;


                return parseInt(data.phase, 10) === 0
                    ? parseInt(data.price * tokens, 10)
                    : parseInt(tempPrice, 10);
            });
        },

        ...

        "sellPrice": (tokens) => {
            return balance(contractAddress).then((data) => {
                return data.length > 0
                    ? parseInt(data[data.length - 1].balance, 10)
                    : 0;
            })
                .then((recentBalance) => {
                    return requestStorage().then((data) => {
                        if (parseInt(data.phase, 10) === 0) {
                            return data.price * tokens;
                        }
                        const factor = tokens / (2 * data.total_tokens),
                            subtract = 1 - factor;

                        if (data.total_tokens > 0) {
                            return parseInt(2 * recentBalance * tokens / data.total_tokens * subtract, 10);
                        }

                        return 0;
                    });
                });
        },
```

<HighlightBox>
    If you want to understand the calculations, please have a look at the Smart Contract Implementation [I](./cso-smart-contract-implementation-part-1) and [II](./cso-smart-contract-implementation-part-2). 
</HighlightBox>


It will also apper in you project, that for a certain information you will need to fetch multiple API endpoints like the `bought` function:

```javascript
const bought = () => {
        return transactions(address, "buy").then((data) => {
            return Promise.all(data.map((transaction) => {
                return requestStorage(transaction.level).then((currentState) => {
                    return requestStorage(transaction.level - 1).then((oldState) => {
                        const oldTokens = typeof oldState.ledger[address] === "undefined"
                                ? 0
                                : oldState.ledger[address],
                            currentTokens = typeof currentState.ledger[address] === "undefined"
                                ? 0
                                : currentState.ledger[address];

                        transaction.tokens = currentTokens - oldTokens;

                        return sentBack(address, transaction.hash).then((adjustment) => {
                            transaction.amount -= adjustment;

                            return transaction;
                        });
                    });
                });
            }));
        });
    }
```

to fetch user interaction, we need to fetch the transactions with `transactions` first and then the storage with `requestStorage`, because we need information about the change in the ledger and the tezos amount sent in the transaction.