---
title: Web Application Stack
description: Interacting with the blockchain
slug: /rolling-safe-platform-stack
---

import HighlightBox from "../../src/components/HighlightBox"

import {
  ExpansionPanel,
  ExpansionPanelList,
  ExpansionPanelListItem
} from 'gatsby-theme-apollo-docs';

<!-- Add description and intro once complete -->

We have two different types of interactions with the blockchain: __transactions__ and __queries__.

As you learned in the previous modules of this course, we need to sign a transaction and send the transaction to a node to perform it. Queries have a different nature. For queries, we are not forced to communicate with a Tezos node directly and we do not need any signatures.

## Transactions

We call the entrypoints like you learned to do so in the [Taquito section](./taquito). You can see in the [contract wrapper](https://github.com/b9lab/tezos-app-project/blob/master/src/contract/contract.js):

```javascript
    return {

        "buy": (tezAmount) => {
            return confirmDefault((contract) => {
                return contract.methods.buy([["unit"]]).send({"amount": tezAmount});
            });
        },
        "sell": (tokenAmount) => {
            return confirmDefault((contract) => {
                return contract.methods.sell(tokenAmount).send();
            });
        },
        ...
    };
```

`contract` is basically `tezos.wallet.at(contractAddress)`, so transactions are signed by a wallet:

```javascript
        wallet = new options.SDK(walletOptions),
        forcePermissionRequest = () => {
            return wallet
                .client
                .requestPermissions({
                    "network": {
                        "type": options.network,
                        "rpcUrl": options.url
                    }
                })
                .then(() => {
                    return wallet;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        };
```

We use `BeaconWallet`.

<HighlightBox type="tip">

Please take a look at the [Beacon section](./beacon) if you are not familiar with it.

</HighlightBox>

## Queries

TzKT API is used to fetch information from the Tezos blockchain. You can find the methods the TZMINT web application implements in the [chainWrapper](https://github.com/b9lab/tezos-app-project/blob/master/src/chain/chain.js) code.

<HighlightBox type="tip">

As a refresher, we recommend a recap of the [TzKT API section](./tzkt) in the _Developing Clients_ chapter.

</HighlightBox>

We need different API endpoints to fetch all the information displayed in the [TZMINT web application](https://tzmint.b9lab.com/). It makes sense to have a function for each of the endpoints we want to use:

```javascript
/* eslint-disable max-lines */
    const requestStorage = (level) => {
            const levelRequest = typeof level === "undefined"
                ? ""
                : `?level=${level}`;


            return axios.get(`${apiEndpoint}v1/contracts/${contractAddress}/storage${levelRequest}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        requestStorageHistory = (limit) => {
            const limitRequest = typeof limit === "undefined"
                ? ""
                : `limit=${limit}`;

            return axios.get(`${apiEndpoint}v1/contracts/${contractAddress}/storage/history?${limitRequest}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        ...
```

`chainWrapper` uses [axios](https://github.com/axios/axios) as HTTP client for the queries. You will see that some functions have optional parameters like the `level` for the storage we request. 

The endpoint to get the storage of a contract is `/contracts/${contractAddress}/storage`. We include a `level` and `levelRequest` because we also want to fetch the storage for a given block level. In addition, we want to be able to fetch the changes in the storage, so there is a `requestStorageHistory` method. For an example, we fetch the price history in order to display it on the platform.

Let us check other methods for the endpoints:

```javascript
        transactions = (sender, entrypoint) => {
            const url = `${apiEndpoint}v1/operations/transactions?target=${contractAddress}`,
                senderFilter = typeof sender === "undefined"
                    ? ""
                    : `&sender=${sender}`,

                entryFilter = typeof entrypoint === "undefined"
                    ? ""
                    : `&entrypoint=${entrypoint}`;

            return axios.get(url + senderFilter + entryFilter)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });

        },
```

Above you will again see the use of optional parameters. `transactions` will return a list of transactions sent to the contract address, where `sender` and `entrypoint` can be used to filter for a specific sender address or a specific entrypoint called in the transactions. 

We need to fetch balances for various purposes:

```javascript
        balance = (address) => {
            return axios.get(`${apiEndpoint}v1/accounts/${address}/balance_history`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
```

and we will fetch some transaction details, like the tez amount sent by the transaction:

```javascript
        payedAmount = (hash) => {
            return axios.get(`${apiEndpoint}v1/operations/transactions/${hash}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        }
```

We want to avoid unnecessary queries, so we use a helper function:

```javascript
        cachedData = (cachedStorage, storageFunction, functionToCache) => {
            if (cachedStorage) {
                return functionToCache(cachedStorage);
            }
            return storageFunction().then(functionToCache);
        };
```

which will check if a new query for the data is wanted. It is enough to fetch some values once because we know the contract logic and we do not expect those values be changed over time, like various parameters about the reserve or phases.

We can make more assumptions about when we expect something to be changed and decrease the number of queries at the API endpoint further. This logic is implemented in the web application part, because we do not want to mix what is separated. Web application part has a DB and can store the `storageData` and therefore it will decide when to fetch new data. So in the wrapper we will offer an optional parameter `storageData` and if the application decides to use old data instead of requesting new data, it will pass the old data kept in a DB:

```javascript
        "mfg": (storageData) => {
            return cachedData(storageData, requestStorage, (data) => {
                return parseInt(data.MFG, 10);
            });
        },
        "sellSlope": (storageData) => {
            return cachedData(storageData, requestStorage, (data) => {
                return parseInt(data.sell_slope, 10);
            });
        },
        ...
        "companyValuation": (storageData) => {
            return cachedData(storageData, requestStorage, (data) => {
                return parseInt(data.company_v, 10);
            });
        },
        "phase": (storageData) => {
            return cachedData(storageData, requestStorage, (data) => {
                return parseInt(data.phase, 10);
            });

        },
```

so you will see the option for caching in the wrapper even for those values which will change over time. 

We cannot easily fetch the sell and buy price. For the `buyPrice`, we do a calculation for a given number of tokens and return the estimated price. This is also true for the `sellPrice`:

```javascript
        "buyPrice": (storageData, tokens) => {
            return cachedData(storageData, requestStorage, (data) => {
                const firstPart = data.buy_price * data.total_tokens * tokens / 2,
                    secondPart = data.buy_price * tokens * (parseInt(data.total_tokens, 10) + tokens) / 2,
                    tempPrice = Math.ceil((firstPart + secondPart)*10)/10;


                return parseInt(data.phase, 10) === 0
                    ? parseInt(data.price * tokens, 10)
                    : parseInt(tempPrice, 10);
            });
        },

        ...

        "sellPrice": (tokens) => {
            return balance(contractAddress).then((data) => {
                return data.length > 0
                    ? parseInt(data[data.length - 1].balance, 10)
                    : 0;
            })
                .then((recentBalance) => {
                    return requestStorage().then((data) => {
                        if (parseInt(data.phase, 10) === 0) {
                            return data.price * tokens;
                        }
                        const factor = tokens / (2 * data.total_tokens),
                            subtract = 1 - factor;

                        if (data.total_tokens > 0) {
                            return parseInt(2 * recentBalance * tokens / data.total_tokens * subtract, 10);
                        }

                        return 0;
                    });
                });
        },
```

<HighlightBox type="tip">

If you want to understand the calculations, please have a look at the previous sections [Smart Contract Implementation I](./rolling-safe-smart-contract-implementation-part-1) and [Smart Contract Implementation II](./rolling-safe-smart-contract-implementation-part-2).

</HighlightBox>

In your own project, you will also face the moment when you will need to fetch multiple API endpoints to get certain information. Like in the case of the `bought` function:

```javascript
const bought = () => {
        // first fetch transactions calling buy entrypoint
        return transactions(address, "buy").then((data) => {
            return Promise.all(data.map((transaction) => {
                // go through the calls
                return requestStorage(transaction.level).then((currentState) => {
                    // then request the storage at the moment of this buy call
                    return requestStorage(transaction.level - 1).then((oldState) => {
                        const oldTokens = typeof oldState.ledger[address] === "undefined"
                                ? 0
                                : oldState.ledger[address],
                            currentTokens = typeof currentState.ledger[address] === "undefined"
                                ? 0
                                : currentState.ledger[address];

                        // check the amount of tokens bought
                        transaction.tokens = currentTokens - oldTokens;

                        // check if there was a transaction for the excess sent back
                        return sentBack(address, transaction.hash).then((adjustment) => {
                            transaction.amount -= adjustment;

                            return transaction;
                        });
                    });
                });
            }));
        });
    }
```

This function will return a list of token purchases for a user. We do not keep track of this list in the web application, so we have to generate it from the blockchain. First we look for transactions calling the buy entrypoint sent by the user. Then we request the storage before and after such a call to see the amount of tokens added in the ledger for the user. In addition we check if an excess was sent back because we want to return the correct amount of tez payed for the amount of tokens.