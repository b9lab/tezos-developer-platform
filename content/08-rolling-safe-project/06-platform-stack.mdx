---
title: Web Application Stack
description: 
slug: /cso-platform-stack
---

import HighlightBox from "../../src/components/HighlightBox"

import {
  ExpansionPanel,
  ExpansionPanelList,
  ExpansionPanelListItem
} from 'gatsby-theme-apollo-docs';

<!-- Add description and intro once complete -->

We have two different types of interactions with the blockchain: __transactions__ and __queries__.

As you learned in the previous modules of this course, we need to sign a transaction and send it to a node to perform it. Queries have a different nature. For queries, we are not forced to communicate with a Tezos node directly and we do not need any signatures.

## Transactions

We call the entrypoints like you learned to do so in the [Taquito section](./taquito). You can see in the [contract wrapper](https://github.com/b9lab/tezos-cso-project):

```javascript
    return {

        "buy": (tezAmount) => {
            return confirmDefault((contract) => {
                return contract.methods.buy([["unit"]]).send({"amount": tezAmount});
            });
        },
        "sell": (tokenAmount) => {
            return confirmDefault((contract) => {
                return contract.methods.sell(tokenAmount).send();
            });
        },
        ...
    };
```

`contract` is basically `tezos.wallet.at(contractAddress)`, so transactions are signed by a wallet:

```javascript
        wallet = new options.SDK(walletOptions),
        forcePermissionRequest = () => {
            return wallet
                .client
                .requestPermissions({
                    "network": {
                        "type": options.network,
                        "rpcUrl": options.url
                    }
                })
                .then(() => {
                    return wallet;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        };
```

We use `BeaconWallet`.

<HighlightBox type="tip">

Please take a look at the [Beacon section](./beacon) if you are not familiar with it.

</HighlightBox>

## Queries

TzKT API is used to fetch information from the Tezos blockchain. You can find the methods the TZMINT web application implements in the [chainWrapper](https://github.com/b9lab/tezos-cso-project) code.

<HighlightBox type="tip">

As a refresher, we recommend a recap of the [TzKT section](./tzkt) in the _Developing Clients_ chapter.

</HighlightBox>

We need different API endpoints to fetch all the information displayed in the [TZMINT web application](https://tzmint.b9lab.com/). It makes sense to have a function for each of the endpoints we want to use:

```javascript
/* eslint-disable max-lines */
    const requestStorage = (level) => {
            const levelRequest = typeof level === "undefined"
                ? ""
                : `?level=${level}`;


            return axios.get(`${apiEndpoint}v1/contracts/${contractAddress}/storage${levelRequest}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        requestStorageHistory = (limit) => {
            const limitRequest = typeof limit === "undefined"
                ? ""
                : `limit=${limit}`;

            return axios.get(`${apiEndpoint}v1/contracts/${contractAddress}/storage/history?${limitRequest}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        ...
```

`chainWrapper` uses [axios](https://github.com/axios/axios) as HTTP client for the queries.

The endpoint to get the storage of a contract is `/contracts/${contractAddress}/storage`. We include a `level` and `levelRequest` because we also want to fetch the storage for a given block level. In addition, we want to be able to fetch the changes in the storage, so there is a `requestStorageHistory` method.

Let us check other methods for the endpoints:

```javascript
        transactions = (sender, entrypoint) => {
            const url = `${apiEndpoint}v1/operations/transactions?target=${contractAddress}`,
                senderFilter = typeof sender === "undefined"
                    ? ""
                    : `&sender=${sender}`,

                entryFilter = typeof entrypoint === "undefined"
                    ? ""
                    : `&entrypoint=${entrypoint}`;

            return axios.get(url + senderFilter + entryFilter)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });

        },
        balance = (address) => {
            return axios.get(`${apiEndpoint}v1/accounts/${address}/balance_history`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        },
        payedAmount = (hash) => {
            return axios.get(`${apiEndpoint}v1/operations/transactions/${hash}`)
                .then((response) => {
                    return response.data;
                })
                .catch((error) => {
                    throw new Error(error);
                });
        }
```

Now, we need some transaction details and account balances. Fortunately, we have a helper function, which is used to avoid unnecessary queries:

```javascript
        cashedData = (cashedStorage, storageFunction, functionToCash) => {
            if (cashedStorage) {
                return functionToCash(cashedStorage);
            }
            return storageFunction().then(functionToCash);
        };
```

First, we can see a lot of from the storage fetched information and we do not always expect such a value to change:

```javascript
    return {
        "storage": requestStorage,
        "totalTokens": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.total_tokens, 10);
            });
        },
        "totalInvestments": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.total_investment, 10);
            });
        },
        "mfg": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.MFG, 10);
            });
        },
        "sellSlope": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.s, 10);
            });
        },

        ...

        "companyValuation": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.company_v, 10);
            });
        },
        "phase": (storageData) => {
            return cashedData(storageData, requestStorage, (data) => {
                return parseInt(data.phase, 10);
            });

        },
```

We cannot easily fetch the sell and buy price. So for the `buyPrice`, we do a calculation for a given number of tokens and return the estimated price. This is also true for the `sellPrice`:

```javascript
        "buyPrice": (storageData, tokens) => {
            return cashedData(storageData, requestStorage, (data) => {
                const firstPart = data.b * data.total_tokens * tokens / 2,
                    secondPart = data.b * tokens * (parseInt(data.total_tokens, 10) + tokens) / 2,
                    tempPrice = Math.ceil((firstPart + secondPart)*10)/10;


                return parseInt(data.phase, 10) === 0
                    ? parseInt(data.price * tokens, 10)
                    : parseInt(tempPrice, 10);
            });
        },

        ...

        "sellPrice": (tokens) => {
            return balance(contractAddress).then((data) => {
                return data.length > 0
                    ? parseInt(data[data.length - 1].balance, 10)
                    : 0;
            })
                .then((recentBalance) => {
                    return requestStorage().then((data) => {
                        if (parseInt(data.phase, 10) === 0) {
                            return data.price * tokens;
                        }
                        const factor = tokens / (2 * data.total_tokens),
                            subtract = 1 - factor;

                        if (data.total_tokens > 0) {
                            return parseInt(2 * recentBalance * tokens / data.total_tokens * subtract, 10);
                        }

                        return 0;
                    });
                });
        },
```

<HighlightBox type="tip">

If you want to understand the calculations, please have a look at the [Smart Contract Implementation I](./cso-smart-contract-implementation-part-1) and the [Smart Contract Implementation II](./cso-smart-contract-implementation-part-2) section.

</HighlightBox>

In your own project, you will also be face the moment when you will need to fetch multiple API endpoints to get certain information. Like in the case of the `bought` function:

```javascript
const bought = () => {
        return transactions(address, "buy").then((data) => {
            return Promise.all(data.map((transaction) => {
                return requestStorage(transaction.level).then((currentState) => {
                    return requestStorage(transaction.level - 1).then((oldState) => {
                        const oldTokens = typeof oldState.ledger[address] === "undefined"
                                ? 0
                                : oldState.ledger[address],
                            currentTokens = typeof currentState.ledger[address] === "undefined"
                                ? 0
                                : currentState.ledger[address];

                        transaction.tokens = currentTokens - oldTokens;

                        return sentBack(address, transaction.hash).then((adjustment) => {
                            transaction.amount -= adjustment;

                            return transaction;
                        });
                    });
                });
            }));
        });
    }
```

To fetch user interaction, we need to first fetch the transactions with `transactions` and then the storage with `requestStorage` to get information on the ledger change and the tez amount sent in the transaction.
